#+TITLE: Prolog-Library-Collection (PLC)
#+AUTHOR: Wouter Beek

A collection of Prolog libraries that extends the functionality
available in the [[http://www.swi-prolog.org][SWI-Prolog]] standard libraries.

* Installation

  1. Install [[http://www.swi-prolog.org][SWI-Prolog]].
  2. Run Prolog and install the [[https://github.com/wouterbeek/ppm][Prolog Package Manager]] (PPM):
     ~pack_install('git://github.com/wouterbeek/ppm').~
  3. Activate PPM: ~[library(ppm)].~
  4. Install Prolog Library Collection:
     ~ppm_install('Prolog-Library-Collection').~

* Usage

In order to access the libraries in the Prolog Library Collection from
the Prolog ~library~ path, you must first load PPM and the libraries
you want to use afterwards:

#+BEGIN_SRC prolog
?- [library(ppm)].
?- [library(atom_ext)].
#+END_SRC

Since the above is a bit cumbersome, it is common practice to place
the PPM load command in the Prolog startup file (~~/.swiplrc~).

* Module overview

** ~archive_ext~

This module extends the standard library ~archive~:

  - ~archive_extension(?Extension:atom)~

    Succeeds if ~Extension~ is a default file name extension for an
    archive filter or format, as declared in library [[media_type]].

  - ~archive_media_type(?MediaType:media)~

    Succeeds if ~MediaType~ is the Media Type of an archive filter or
    format.

  - ~archive_open(+In:stream, -Archive:blob)~

    Opens an archive over all supported and sensible archive filters
    and formats.  This specifically excludes format ~mtree~, which is
    a plain text format that is almost never used yet leads to many
    false positives in practice.

** ~assoc_ext~

This module extends the standard library ~assoc~:

  - ~merge_assoc(+New:assoc, +Old:assoc, -Merge:assoc)~

    Merges two assocs into a new one.  If the same key exists in ~New~
    and ~Old~, the format replaces the latter in ~Merge~.  These
    semantics are inspired by those of the standard library predicate
    ~merge_options/3~ in library ~option~.

  - ~transpose_assoc(+Assoc:assoc, -Transposed:assoc)~

    Turns an assoc of (key,value) pairs into one with(value,key)
    pairs.

** ~atom_ext~

  - ~atom_capitalize(+Original:atom, -Capitalized:atom)~

    ~Capitalized~ is like ~Orginal~, but its first character is
    ensured to be in upper case (if possible).

  - ~atom_ellipsis(+Original:atom, ?MaxLength:nonneg, ?Ellipsed:atom)~


Support for working with atoms, e.g., capitalization, ellipsis, strip, truncate.

** ~call_ext~
meta-predicates
** ~code_ext~
** ~conf_ext~
** ~csv_ext~
Streamed processing of CSV files.
** ~date_time~
** ~/dcg~ Definite Clause Grammars

In directory ~/dcg~ you will find a collection of Definite Clause
Grammar (DCG) modules.

** ~/dcg/dcg_abnf.pl~ Advanced Bauckus-Naur Form (ABNF)

While DCGs are nice, they can be a bit verbose for expressing common
repetition patterns.  To make DCGs that include repetitions less
verbose, this module implements *variable repetition* as defined in
[[https://tools.ietf.org/html/rfc5234][RFC 5234: Augmented BNF for Syntax Specifications: ABNF]].

*** A simple example

Suppose we want to parse sentences, which are non-empty sequences of
words:

#+BEGIN_SRC prolog
sentence1([H|T]) -->
  word(H),
  sentece2(T).

sentence2([H|T]) -->
  word(H),
  sentence2(T)
sentence2([]) --> "".
#+END_SRC

When this module is loaded, the same can be written as follows:

#+BEGIN_SRC prolog
sentence(L) -->
  +(word, L).
#+END_SRC

*** definition

**** variable repetition

Variable repetition is a metasyntactic construct which states that
at least ~M~ and at most ~N~ occurrences of ~:Dcg_0~ must be
processed:

#+BEGIN_SRC prolog
'm*n'(?M:nonneg, ?N:nonneg, :Dcg_0)//
#+END_SRC

**** specific repetition

Specific repetition is a metasyntactic construct which states that
exactly ~N~ occurrences of ~Dcg_0~ must be processed:

#+BEGIN_SRC prolog
'#'(?N:nonneg, :Dcg_0)//
#+END_SRC

Specific repetition is a special case of [[variable repetition]], because
~#(N, Dcg_0)~ is the same as ~'m*n'(N, N, Dcg_0)~.

**** Kleene star

Kleene star is a metasyntactic construct which states that zero or
more occurrences of ~Dcg_0~ must be processed:

#+BEGIN_SRC prolog
*(?N:nonneg, :Dcg_0)//
#+END_SRC

Kleene star is a special case of [[variable repetition]], because ~*(N,
Dcg_0)~ is the same as ~'m*n'(_, _, Dcg_0)~.

**** Kleene sum

Kleene sum is a metasyntactic construct which states that one or more
occurrences of ~Dcg_0~ must be processed:

#+BEGIN_SRC prolog
+(?N:nonneg, :Dcg_0)//
#+END_SRC

Kleene sum is a special case of [[variable repetition]], because ~+(N,
Dcg_0)~ is the same as ~'m*n'(1, _, Dcg_0)~.

**** optional sequence

Optional sequence is a metasyntactic construct which states that
~Dcg_0~ should either be processed once or not at all:

#+BEGIN_SRC prolog
?(:Dcg_0)//
#+END_SRC

Optional sequence is a special case of [[variable repetition]], because
~?(Dcg_0)~ is the same as ~'m*n'(0, 1, Dcg_0)~.

| *DCG*                     | *Meaning*                                           | *Name*              |
|---------------------------+-----------------------------------------------------+---------------------|
| ~#(?N, :Dcg_0)//~         | Process ~Dcg_0~ exactly ~N~ times.                  | [[specific repetition]] |
| ~*(:Dcg_0)//~             | Process ~Dcg_0~ 0 or more times.                    | [[Kleene star]]         |
| ~'*n'(?N, :Dcg_0)//~      | Process ~Dcg_0~ at most ~N~ times.                  |                     |
| ~+(:Dcg_0)//~             | Process ~Dcg_0~ 1 or more times.                    | [[Kleene sum]]          |
| ~?(:Dcg_0)//~             | Process ~Dcg_0~ 0 or 1 times.                       | [[optional sequence]]   |
| ~'m*'(?M, :Dcg_0)//~      | Process ~Dcg_0~ at least ~M~ times.                 |                     |
| ~'m*n'(?M, ?N, :Dcg_0)//~ | Process ~Dcg_0~ at least ~M~ and at most ~N~ times. | [[variable repetition]] |
  It contains the
following modules:

| *Type*  | *Definition*                                                                                                       |
|---------+--------------------------------------------------------------------------------------------------------------------|
| ~media~ | A compound term of the form ~media(Super:atom/Sub:atom,Parameters:list(opt))~                                      |
| ~opt~   | A unary compound term whose predicate letter is an option name and whose argument is a corresponding option value. |

** ~default~
** ~dict_ext~
SWI7 dictionaries
** ~dlist~
difference lists
** ~file_ext~
Handling files and directories.
** ~geo/~
Parsing & generating of Well-Known Text (WKT) strings.
** ~has_ext~
** ~http/~
HTTP client & server support.
** ~json_ext~
** ~list_ext~
** ~math_ext~
** ~media_type~ <<media_type>>
** ~nlp/~
** ~os_ext~
Running external processes, streaming to/from external processes.
** ~pair_ext~
** ~pp~
** ~sort_ext~
** ~stream_ext~
Support for recoding, unpacking, sorting, and hasing streams.
** ~string_ext~
** ~uri/~
Constructing/decomposing URIs.
** ~write_ext~
** ~xml/~
Streamed processing of XML DOMs.
